{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 16eda245d849d08b8e04","webpack:///external \"cheerio\"","webpack:///external \"lodash\"","webpack:///external \"request-promise\"","webpack:///external \"js-yaml\"","webpack:///external \"fs\"","webpack:///./src/helpers/loader.js","webpack:///./src/helpers/rule.js","webpack:///./src/index.js","webpack:///./src/helpers/index.js","webpack:///./src/helpers/linter.js","webpack:///./node_modules/babel-runtime/regenerator/index.js","webpack:///external \"regenerator-runtime\"","webpack:///external \"path\"","webpack:///./src/constants/index.js","webpack:///external \"stream\""],"names":["root","factory","exports","module","define","amd","a","i","self","this","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","require","request","cheerio","fs","path","stream","yaml","loadYamlConfig","filename","config","resolve","existsSync","Promise","reject","cfg","safeLoad","readFileSync","Error","err","loadUrl","url","startsWith","uri","toLowerCase","headers","User-Agent","transform","body","load","then","$","loadFile","obj","readFile","html","Readable","_typeof","_read","_readableState","on","loadHTML","TagRule","tagName","_ref","_ref$parent","parent","undefined","_ref$required","required","_ref$max","max","_ref$min","min","_ref$attrs","attrs","_ref$childs","childs","_classCallCheck","_tagName","SEOLinter","loader","_extends","_","ERROR_CODE","rules","isObject","errors","tags","initRules","_this","rulesMap","keys","forEach","rule","tagRules","isArray","createTagRules","createTagRule","concat","_toConsumableArray","cfgRule","key","cfgRules","_this2","map","_this3","tag","find","code","message","_this4","_rulesMap$tagName","reduce","validateRule","_this5","_ref2","arguments","length","elmLen","trim","msgPrnt","push","createError","ERR_TAG_NOT_FOUND","ERR_TAG_MAX_EXCEED","ERR_TAG_MIN_UNDER","isEmpty","attrErrors","validateAttrs","_errs","r","_this6","attrNames","attrMap","attrNm","value","each","elm","present","matched","attrVal","attribs","_attrMap$attrNm","attr","notPresent","ERR_ATTR_NOT_FOUND","notMatched","errMsg","ERR_ATTR_NOT_EQUAL","file","output","type","silence","assignElement","_this7","validate","writeOut","indexOf","printErrors","createWriteStream","textToWrite","toOutputString","once","write","Buffer","end","_this8","str","_ref6","console","log"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 16eda245d849d08b8e04","module.exports = require(\"cheerio\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cheerio\"\n// module id = 0\n// module chunks = 0 1","module.exports = require(\"lodash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 1\n// module chunks = 0 1","module.exports = require(\"request-promise\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"request-promise\"\n// module id = 2\n// module chunks = 0 1","module.exports = require(\"js-yaml\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"js-yaml\"\n// module id = 3\n// module chunks = 0 1","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 4\n// module chunks = 0","'use strict';\n\nconst request = require('request-promise');\nconst cheerio = require('cheerio');\nconst fs = require('fs');\nconst path = require('path');\nconst stream = require('stream');\nconst yaml = require('js-yaml');\n\nconst isReadableStream = obj =>\n  obj instanceof stream.Readable &&\n  typeof (obj._read === 'function') &&\n  typeof (obj._readableState === 'object');\n/**\n * Load yaml config file to javascript object\n *\n * @param {string} filename: provide the absolute path of yaml configuration file.\n * @param {string} config stands for key of configuration\n */\nexports.loadYamlConfig = (filename, config) => {\n  if (!filename) {\n    filename = path.resolve('config.yml');\n  }\n  if (!fs.existsSync(filename))\n    return Promise.reject(\n      new Error(`Provied path (${filename}) does not exist!`)\n    );\n\n  return new Promise((resolve, reject) => {\n    try {\n      const cfg = yaml.safeLoad(fs.readFileSync(filename, 'utf8'));\n      if (config && !cfg[config])\n        throw new Error(`Config with name '${config}' doesn't exist`);\n      return config ? resolve(cfg[config]) : resolve(cfg);\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n\n/**\n * Load page content from url\n *\n * @param {string} url\n * @returns { $ } cheerio wrapped html tag\n * @example:\n * const { loadUrl } = require('./helper');\n * const { $ } = await loadUrl('https://google.com.vn');\n */\nexports.loadUrl = url => {\n  if (!url.startsWith('http://') && !url.startsWith('https://')) {\n    return Promise.reject(\n      new Error('URL must be start with either http:// or https://')\n    );\n  }\n  const uri = url.toLowerCase();\n  const options = {\n    uri,\n    headers: {\n      'User-Agent': 'Request-Promise'\n    },\n    transform: body => {\n      return cheerio.load(body);\n    }\n  };\n\n  return request(options).then($ => $('html'));\n};\n\n/**\n * Load page content from HTML file\n *\n * @param {string} html path\n * @returns { $ } cheerio wrapped html tag\n * @example:\n * const { loadFile } = require('./helper');\n * const { $ } = await loadFile('/path/to/htmlfile.html');\n */\nexports.loadFile = filename => {\n  if (!filename) return Promise.reject(new Error('Filename is required'));\n  return new Promise((resolve, reject) => {\n    if (typeof filename === 'string') {\n      fs.readFile(filename, (err, html) => {\n        if (err) return reject(err);\n        const $ = cheerio.load(html);\n        return resolve($('html'));\n      });\n    } else if (isReadableStream(filename)) {\n      filename.on('data', html => {\n        const $ = cheerio.load(html);\n        resolve($('html'));\n      });\n    } else {\n      reject(new Error('Filename was provided but invalid'));\n    }\n  });\n};\n\n/**\n * Load page content from HTML string\n *\n * @param {string} html string\n * @returns { $ } cheerio wrapped html tag\n * @example:\n * const { loadHTML } = require('./helper');\n * const { $ } = await loadHTML('<html>...</html>');\n */\nexports.loadHTML = html => {\n  if (!html)\n    return Promise.reject(\n      new Error('HTML argument is required and it should not be empty')\n    );\n  const $ = cheerio.load(html);\n  return Promise.resolve($('html'));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/loader.js","/**\n * TagRule\n *\n * max { -1 => Unlimited }\n * min { 0 => No required min }\n */\nclass TagRule {\n  constructor(\n    tagName,\n    {\n      parent = undefined,\n      required = false,\n      max = -1,\n      min = 0,\n      attrs = {},\n      childs = []\n    }\n  ) {\n    if (!tagName) throw new Error('tagName is required');\n    this._tagName = tagName;\n    this.parent = parent;\n    this.required = required || false;\n    this.max = max || -1;\n    this.min = min || 0;\n    this.attrs = attrs || {};\n    this.childs = childs || [];\n  }\n\n  get tagName() {\n    return this._tagName;\n  }\n}\n\nmodule.exports = TagRule;\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/rule.js","'use strict';\nconst { SEOLinter, loadYamlConfig } = require('./helpers');\n\nmodule.exports = {\n  SEOLinter,\n  loadYamlConfig\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict';\n\nconst SEOLinter = require('./linter');\nconst loader = require('./loader');\nconst TagRule = require('./rule');\n\nmodule.exports = {\n  SEOLinter,\n  TagRule,\n  ...loader\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/index.js","'use strict';\n\nconst _ = require('lodash');\nconst cheerio = require('cheerio');\nconst fs = require('fs');\n\nconst { loadUrl, loadHTML, loadFile } = require('./loader');\nconst TagRule = require('./rule');\nconst { ERROR_CODE } = require('../constants');\n\nclass SEOLinter {\n  constructor({ rules }) {\n    if (!rules) throw new Error('Rules is required!');\n    if (!_.isObject(rules)) throw new Error('Rules must be an object!');\n\n    this.errors = [];\n    this.tags = [];\n\n    //init rules\n    this.initRules(rules);\n  }\n\n  /**\n   * initilize rules of SEO Linter\n   *\n   * @param {Object} rules\n   */\n  initRules(rules) {\n    this.rulesMap = {};\n    this.tags = Object.keys(rules);\n    this.tags.forEach(tagName => {\n      this.rulesMap[tagName] = { rules: [] }; \n    });\n    this.tags.forEach(tagName => {\n      const rule = rules[tagName];\n      const tagRules = _.isArray(rule)\n        ? this.createTagRules(tagName, rule)\n        : [this.createTagRule(tagName, rule)];\n\n      this.rulesMap[tagName]['rules'] = [\n        ...this.rulesMap[tagName]['rules'],\n        ...tagRules\n      ];\n    });\n  }\n\n  /**\n   * Create TagRule instance based on configuration\n   *\n   * @param {Object} cfgRule\n   * @returns {TagRule} instance of TagRule\n   */\n  createTagRule(tagName, cfgRule, parent) {\n    if (!tagName) {\n      tagName = Object.keys(cfgRule)[0];\n      cfgRule = cfgRule[tagName];\n    }\n    return new TagRule(tagName, { ...cfgRule, parent });\n  }\n\n  /**\n   * Create list of TagRule based of configurations\n   *\n   * @param {Array} cfgRules\n   * @returns {Array<TagRule>} list of TagRule\n   *\n   */\n  createTagRules(key, cfgRules) {\n    return cfgRules.map(rule => this.createTagRule(key, rule));\n  }\n\n  /**\n   * Assign Cheerio Element to Each rule\n   *\n   * @param {*} $ cheerio document object\n   */\n  assignElement($) {\n    this.tags.forEach(tag => {\n      this.rulesMap[tag]['$'] = $.find(tag);\n    });\n  }\n\n  /**\n   * Create an error that\n   */\n  createError(rule, code, message) {\n    return {\n      code,\n      message,\n      tagName: rule.tagName\n    };\n  }\n\n  /**\n   * Validate rule by tagName\n   *\n   * @param {string} tagName\n   * @returns {Array} errors - If errors is empty mean HTML document is valid with provided rules.\n   */\n  validate(tagName) {\n    const { rules, $ } = this.rulesMap[tagName];\n    return rules.reduce(\n      (errors, rule) => errors.concat(this.validateRule({ rule, $ })),\n      []\n    );\n  }\n\n  /**\n   * Validate each rule by TagRule instance\n   *\n   * @param {Object} param0 should be like this: { rule, $ }\n   * @param {*} errors\n   */\n  validateRule({ rule, $ }, errors = []) {\n    const { tagName, required, max, min, attrs, childs, parent } = rule;\n    if (parent) {\n      $ = $.find(tagName);\n    }\n    let elmLen = $.length;\n    if (tagName === 'head' && $.html().trim() === '') {\n      elmLen = 0;\n    }\n\n    // Check if required and existed first\n    if (required && elmLen === 0) {\n      const msgPrnt = parent ? `<${parent}> tag` : 'HTML document';\n      errors.push(\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_NOT_FOUND,\n          `${msgPrnt} required <${tagName}> tag but it doesn't exist`\n        )\n      );\n      return errors;\n    }\n\n    // Check max of element in document\n    if (max !== -1 && elmLen > max) {\n      errors.push(\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_MAX_EXCEED,\n          `The maximum element of <${tagName}> tag is ${max} but this HTML document has ${elmLen} <${tagName}> tags.`\n        )\n      );\n    }\n\n    // Check min of element in document\n    if (min !== 0 && elmLen < min) {\n      errors.push(\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_MIN_UNDER,\n          `The minimum element of <${tagName}> tag is ${min} but this HTML document has ${elmLen} <${tagName}> tags.`\n        )\n      );\n    }\n\n    // Check attributes (Each attr has 2 prop. Ex: { required, value })\n    if (!_.isEmpty(attrs)) {\n      const attrErrors = this.validateAttrs(rule, $);\n      errors = errors.concat(attrErrors);\n    }\n\n    // Recursive with childs element\n    if (rule.childs.length > 0) {\n      errors = rule.childs.reduce(\n        (_errs, r) =>\n          _errs.concat(\n            this.validateRule(\n              {\n                rule: this.createTagRule(null, r, rule.tagName),\n                $\n              },\n              errors\n            )\n          ),\n        []\n      );\n    }\n    return errors;\n  }\n\n  /**\n   * Validate Attributes of each element\n   *    1. Check attr required or not\n   *    2. Check attr required & attr has specified value\n   *\n   * @param {TagRule} rule\n   * @param {*} $ DOMElement wrapped by cheerio object\n   */\n  validateAttrs(rule, $) {\n    const { attrs, parent } = rule;\n    const elmLen = $.length;\n    const attrNames = Object.keys(attrs);\n    const attrMap = {};\n    let attrErrors = [];\n\n    if (elmLen === 0)\n      return attrNames.map(attrNm =>\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_NOT_FOUND,\n          `<${rule.tagName} ${attrNm}='${attrs[attrNm].value ||\n            ''}'> was not found in ${\n            parent ? '<' + parent + '> tag' : 'HTML document'\n          }`\n        )\n      );\n\n    $.each((_, elm) => {\n      // Loop each element and check attrs in each one.\n      attrNames.forEach(attrNm => {\n        const { value } = attrs[attrNm];\n        if (!attrMap.hasOwnProperty(attrNm)) {\n          // present stands for number of element that contains attr, matched stands for number of attr mached value\n          attrMap[attrNm] = { present: 0, matched: 0 };\n        }\n        const attrVal = elm.attribs[attrNm];\n        if (attrVal) {\n          attrMap[attrNm].present += 1;\n          if (attrVal == value && value) {\n            attrMap[attrNm].matched += 1;\n          }\n        }\n      });\n    });\n\n    attrNames.forEach(attrNm => {\n      const { present, matched } = attrMap[attrNm];\n      const attr = attrs[attrNm];\n      if (attr.required) {\n        const notPresent = elmLen - present;\n        if (notPresent > 0) {\n          attrErrors.push(\n            this.createError(\n              rule,\n              ERROR_CODE.ERR_ATTR_NOT_FOUND,\n              `There are ${notPresent} <${\n                rule.tagName\n              }> tags without [${attrNm}] attribute`\n            )\n          );\n        }\n      }\n\n      if (attr.value) {\n        const notMatched = elmLen - matched;\n        if (notMatched > 0 && notMatched < elmLen && !attr.min) {\n          let errMsg = `There are ${elmLen} <${\n            rule.tagName\n          }> tags but there are ${notMatched} tags have no attribute [${attrNm}='${\n            attr.value\n          }'].`;\n          attrErrors.push(\n            this.createError(rule, ERROR_CODE.ERR_ATTR_NOT_EQUAL, errMsg)\n          );\n        }\n\n        if (matched < (attr.min || 0)) {\n          attrErrors.push(\n            this.createError(\n              rule,\n              ERROR_CODE.ERR_ATTR_NOT_EQUAL,\n              `At least ${attr.min} <${\n                rule.tagName\n              }> tags must have attribute [${attrNm}='${\n                attr.value\n              }']. Need more ${attr.min - matched} <${\n                rule.tagName\n              } ${attrNm}='${attr.value}'> tags.`\n            )\n          );\n        }\n\n        if (notMatched === elmLen) {\n          attrErrors.push(\n            this.createError(\n              rule,\n              ERROR_CODE.ERR_ATTR_NOT_EQUAL,\n              `${parent ? '<' + parent + '> tag' : 'HTML'} required <${\n                rule.tagName\n              }> tag present with attribute [${attrNm}='${\n                attr.value\n              }'] but no one is valid`\n            )\n          );\n        }\n      }\n    });\n\n    return attrErrors;\n  }\n\n  /**\n   * Linting html or page by rules configuration\n   *\n   * @param { uri, html, file, rules}\n   *    Options required uri | html | file && rules && output\n   *    output is an object that has 2 props: { type, path }\n   *      output.type must be either of [console, file]\n   *      output.path required when output.type equals to file and file is a path\n   */\n  async lint({\n    uri,\n    html,\n    file,\n    rules,\n    output = { type: 'console', silence: false }\n  }) {\n    // Make sure that every argument present correctly\n    if (!uri && !html && !file)\n      throw new Error(\n        'You must provide either uri, html, file or readable stream for linting.'\n      );\n    if (rules) {\n      this.initRules(rules);\n    }\n\n    // create cheerio instance based on html content or loading from uri\n    let $;\n    if (uri) {\n      $ = await loadUrl(uri);\n    } else if (html) {\n      $ = await loadHTML(html);\n    } else if (file) {\n      $ = await loadFile(file);\n    }\n\n    // assign cheerio element object for reach rule.\n    this.assignElement($);\n\n    // Get all tags in rules configurations and validate each one.\n    this.errors = this.tags.reduce(\n      (errors, tag) => errors.concat(this.validate(tag)),\n      []\n    );\n\n    // If there is any invalid term, the errors size will be greater than 0\n    if (this.errors.length === 0) return this.errors;\n\n    return this.writeOut(output);\n  }\n\n  /**\n   * Write result to stdout or file\n   *\n   * @param {Object} output -> { type, file }\n   */\n  async writeOut(output) {\n    if (output) {\n      const { type, silence } = output;\n      let file = null;\n      if (['console', 'file'].indexOf(type) === -1)\n        throw new Error(\n          `Output type [${type}] is not valid. Accepted output are [console, file]`\n        );\n\n      if (type === 'console') {\n        if (!silence) this.printErrors();\n        return this.errors;\n      }\n\n      if (type === 'file' && !output.path) {\n        throw new Error('Provied path must be correct and existed');\n      }\n\n      if (typeof output.path === 'string') {\n        file = fs.createWriteStream(output.path);\n      } else {\n        file = output.path;\n      }\n\n      const textToWrite = this.toOutputString();\n\n      return new Promise((resolve, reject) => {\n        file.once('open', () => {\n          file.write(new Buffer(textToWrite, 'utf8'));\n          file.end();\n        });\n\n        file.on('finish', () => {\n          resolve(this.errors);\n        });\n      });\n    }\n  }\n\n  /**\n   * Create result string with line by line style\n   *\n   * @returns {string}\n   */\n  toOutputString() {\n    let str = '';\n    let i = 0;\n    this.errors.forEach(({ code, message }) => {\n      str += `[${++i}][${code}] ${message}\\n`;\n    });\n    return str;\n  }\n\n  /**\n   * Show result string in console\n   *\n   */\n  printErrors() {\n    console.log(this.toOutputString());\n  }\n}\n\nmodule.exports = SEOLinter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/linter.js","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/regenerator/index.js\n// module id = 10\n// module chunks = 0","module.exports = require(\"regenerator-runtime\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"regenerator-runtime\"\n// module id = 11\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 12\n// module chunks = 0","exports.ERROR_CODE = {\n  ERR_TAG_NOT_FOUND: 'TAG001', // Tag required but not existed\n  ERR_TAG_MAX_EXCEED: 'TAG002', // Tag required total of element is X but has exceed the limit\n  ERR_TAG_MIN_UNDER: 'TAG003', // Tag required total of element is Y but has under the limit\n  ERR_ATTR_NOT_FOUND: 'ATTR001', // Tag requires attr present but not\n  ERR_ATTR_NOT_EQUAL: 'ATTR002' // Tag requires attr present with value but not\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants/index.js","module.exports = require(\"stream\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"stream\"\n// module id = 20\n// module chunks = 0"],"sourceRoot":""}