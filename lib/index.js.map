{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 112095e3071c4b6dd99b","webpack:///external \"cheerio\"","webpack:///external \"lodash\"","webpack:///external \"request-promise\"","webpack:///external \"js-yaml\"","webpack:///external \"fs\"","webpack:///./src/helpers/loader.js","webpack:///./src/helpers/rule.js","webpack:///./src/index.js","webpack:///./src/helpers/index.js","webpack:///./src/helpers/linter.js","webpack:///./node_modules/babel-runtime/regenerator/index.js","webpack:///external \"regenerator-runtime\"","webpack:///external \"path\"","webpack:///./src/constants/index.js"],"names":["root","factory","exports","module","define","amd","a","i","self","this","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","require","request","cheerio","fs","path","yaml","loadYamlConfig","filename","config","resolve","existsSync","Promise","reject","cfg","safeLoad","readFileSync","err","Error","loadUrl","url","startsWith","uri","toLowerCase","headers","User-Agent","transform","body","load","then","$","loadFile","readFile","html","loadHTML","TagRule","tagName","_ref","_ref$parent","parent","undefined","_ref$required","required","_ref$max","max","_ref$min","min","_ref$attrs","attrs","_ref$childs","childs","_classCallCheck","_tagName","SEOLinter","loader","_extends","_","ERROR_CODE","rules","isObject","errors","tags","initRules","_this","rulesMap","keys","forEach","rule","tagRules","isArray","createTagRules","createTagRule","concat","_toConsumableArray","cfgRule","isEmpty","key","cfgRules","_this2","map","_this3","tag","find","code","msg","message","_this4","_rulesMap$tagName","reduce","validateRule","_this5","_ref2","arguments","length","elmLen","trim","msgPrnt","push","createError","ERR_TAG_NOT_FOUND","ERR_TAG_MAX_EXCEED","ERR_TAG_MIN_UNDER","attrErrors","validateAttrs","_errs","r","_this6","attrNames","attrMap","attrNm","value","each","elm","present","matched","attrVal","attribs","_attrMap$attrNm","attr","notPresent","ERR_ATTR_NOT_FOUND","notMatched","errMsg","ERR_ATTR_NOT_EQUAL","file","output","type","silence","assignElement","_this7","validate","writeOut","indexOf","printErrors","createWriteStream","textToWrite","toOutputString","once","write","Buffer","end","on","_this8","str","_ref6","console","log"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 112095e3071c4b6dd99b","module.exports = require(\"cheerio\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cheerio\"\n// module id = 0\n// module chunks = 0 1","module.exports = require(\"lodash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 1\n// module chunks = 0 1","module.exports = require(\"request-promise\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"request-promise\"\n// module id = 2\n// module chunks = 0 1","module.exports = require(\"js-yaml\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"js-yaml\"\n// module id = 3\n// module chunks = 0 1","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 4\n// module chunks = 0","'use strict';\n\nconst request = require('request-promise');\nconst cheerio = require('cheerio');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('js-yaml');\n\n/**\n * Load yaml config file to javascript object\n *\n * @param {string} filename: provide the absolute path of yaml configuration file.\n * @param {string} config stands for key of configuration\n */\nexports.loadYamlConfig = (filename, config) => {\n  if (!filename) {\n    filename = path.resolve('config.yml');\n  }\n  if (!fs.existsSync(filename))\n    return Promise.reject(\n      new Error(`Provied path (${filename}) does not exist!`)\n    );\n\n  return new Promise((resolve, reject) => {\n    try {\n      const cfg = yaml.safeLoad(fs.readFileSync(filename, 'utf8'));\n      return config ? resolve(cfg[config]) : resolve(cfg);\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n\n/**\n * Load page content from url\n *\n * @param {string} url\n * @returns { $ } cheerio wrapped html tag\n * @example:\n * const { loadUrl } = require('./helper');\n * const { $ } = await loadUrl('https://google.com.vn');\n */\nexports.loadUrl = url => {\n  if (!url.startsWith('http://') && !url.startsWith('https://')) {\n    return Promise.reject(\n      new Error('URL must be start with either http:// or https://')\n    );\n  }\n  const uri = url.toLowerCase();\n  const options = {\n    uri,\n    headers: {\n      'User-Agent': 'Request-Promise'\n    },\n    transform: body => {\n      return cheerio.load(body);\n    }\n  };\n\n  return request(options).then($ => $('html'));\n};\n\n/**\n * Load page content from HTML file\n *\n * @param {string} html path\n * @returns { $ } cheerio wrapped html tag\n * @example:\n * const { loadFile } = require('./helper');\n * const { $ } = await loadFile('/path/to/htmlfile.html');\n */\nexports.loadFile = filename => {\n  if (!filename) return Promise.reject(new Error('Filename is required'));\n  // TODO: check if filename is readable stream, provide without reading file from path\n  if (!fs.existsSync(filename))\n    return Promise.reject(\n      new Error(`Path provied <${filename}> does not exist`)\n    );\n  return new Promise((resolve, reject) => {\n    fs.readFile(filename, (err, html) => {\n      if (err) return reject(err);\n      const $ = cheerio.load(html);\n      return resolve($('html'));\n    });\n  });\n};\n\n/**\n * Load page content from HTML string\n *\n * @param {string} html string\n * @returns { $ } cheerio wrapped html tag\n * @example:\n * const { loadHTML } = require('./helper');\n * const { $ } = await loadHTML('<html>...</html>');\n */\nexports.loadHTML = html => {\n  if (!html)\n    return Promise.reject(\n      new Error('HTML argument is required and it should not be empty')\n    );\n  const $ = cheerio.load(html);\n  return Promise.resolve($('html'));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/loader.js","/**\n * TagRule\n *\n * max { -1 => Unlimited }\n * min { 0 => No required min }\n */\nclass TagRule {\n  constructor(\n    tagName,\n    {\n      parent = undefined,\n      required = false,\n      max = -1,\n      min = 0,\n      attrs = {},\n      childs = []\n    }\n  ) {\n    if (!tagName) throw new Error('tagName is required');\n    this._tagName = tagName;\n    this.parent = parent;\n    this.required = required || false;\n    this.max = max || -1;\n    this.min = min || 0;\n    this.attrs = attrs || {};\n    this.childs = childs || [];\n  }\n\n  get tagName() {\n    return this._tagName;\n  }\n}\n\nmodule.exports = TagRule;\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/rule.js","'use strict';\nconst { SEOLinter, loadYamlConfig } = require('./helpers');\n\nmodule.exports = {\n  SEOLinter,\n  loadYamlConfig\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict';\n\nconst SEOLinter = require('./linter');\nconst loader = require('./loader');\nconst TagRule = require('./rule');\n\nmodule.exports = {\n  SEOLinter,\n  TagRule,\n  ...loader\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/index.js","'use strict';\n\nconst _ = require('lodash');\nconst cheerio = require('cheerio');\nconst fs = require('fs');\n\nconst { loadUrl, loadHTML, loadFile } = require('./loader');\nconst TagRule = require('./rule');\nconst { ERROR_CODE } = require('../constants');\n\nclass SEOLinter {\n  constructor({ rules }) {\n    if (!rules) throw new Error('Rules is required!');\n    if (!_.isObject(rules)) throw new Error('Rules must be an object!');\n\n    this.errors = [];\n    this.tags = [];\n\n    //init rules\n    this.initRules(rules);\n  }\n\n  /**\n   * initilize rules of SEO Linter\n   *\n   * @param {Object} rules\n   */\n  initRules(rules) {\n    this.rulesMap = {};\n    this.tags = Object.keys(rules);\n    this.tags.forEach(tagName => {\n      const rule = rules[tagName];\n      const tagRules = _.isArray(rule)\n        ? this.createTagRules(tagName, rule)\n        : [this.createTagRule(tagName, rule)];\n\n      if (!this.rulesMap.hasOwnProperty(tagName)) {\n        this.rulesMap[tagName] = { rules: tagRules };\n      } else {\n        this.rulesMap[tagName]['rules'] = [\n          ...this.rulesMap[tagName]['rules'],\n          ...tagRules\n        ];\n      }\n    });\n  }\n\n  /**\n   * Create TagRule instance based on configuration\n   *\n   * @param {Object} cfgRule\n   * @returns {TagRule} instance of TagRule\n   */\n  createTagRule(tagName, cfgRule, parent) {\n    if (!tagName) {\n      if (_.isEmpty(cfgRule)) throw new Error('Configuration is invalid');\n      tagName = Object.keys(cfgRule)[0];\n      cfgRule = cfgRule[tagName];\n    }\n    return new TagRule(tagName, { ...cfgRule, parent });\n  }\n\n  /**\n   * Create list of TagRule based of configurations\n   *\n   * @param {Array} cfgRules\n   * @returns {Array<TagRule>} list of TagRule\n   *\n   */\n  createTagRules(key, cfgRules) {\n    return cfgRules.map(rule => this.createTagRule(key, rule));\n  }\n\n  /**\n   * Assign Cheerio Element to Each rule\n   *\n   * @param {*} $ cheerio document object\n   */\n  assignElement($) {\n    this.tags.forEach(tag => {\n      this.rulesMap[tag]['$'] = $.find(tag);\n    });\n  }\n\n  /**\n   * Create an error that\n   */\n  createError(rule, code, msg) {\n    return {\n      code,\n      message: msg ? msg : `Error from <${rule.tagName}>`,\n      tagName: rule.tagName\n    };\n  }\n\n  /**\n   * Validate rule by tagName\n   *\n   * @param {string} tagName\n   * @returns {Array} errors - If errors is empty mean HTML document is valid with provided rules.\n   */\n  validate(tagName) {\n    const { rules, $ } = this.rulesMap[tagName];\n    return rules.reduce(\n      (errors, rule) => errors.concat(this.validateRule({ rule, $ })),\n      []\n    );\n  }\n\n  /**\n   * Validate each rule by TagRule instance\n   *\n   * @param {Object} param0 should be like this: { rule, $ }\n   * @param {*} errors\n   */\n  validateRule({ rule, $ }, errors = []) {\n    const { tagName, required, max, min, attrs, childs, parent } = rule;\n    if (parent) {\n      $ = $.find(tagName);\n    }\n    let elmLen = $.length;\n    if (tagName === 'head' && $.html().trim() === '') {\n      elmLen = 0;\n    }\n\n    // Check if required and existed first\n    if (required && elmLen === 0) {\n      const msgPrnt = parent ? `<${parent}> tag` : 'HTML document';\n      errors.push(\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_NOT_FOUND,\n          `${msgPrnt} required <${tagName}> tag but it doesn't exist`\n        )\n      );\n      return errors;\n    }\n\n    // Check max of element in document\n    if (max !== -1 && elmLen > max) {\n      errors.push(\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_MAX_EXCEED,\n          `The maximum element of <${tagName}> tag is ${max} but this HTML document has ${elmLen} <${tagName}> tags.`\n        )\n      );\n    }\n\n    // Check min of element in document\n    if (min !== 0 && elmLen < min) {\n      errors.push(\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_MIN_UNDER,\n          `The minimum element of <${tagName}> tag is ${min} but this HTML document has ${elmLen} <${tagName}> tags.`\n        )\n      );\n    }\n\n    // Check attributes (Each attr has 2 prop. Ex: { required, value })\n    if (!_.isEmpty(attrs)) {\n      const attrErrors = this.validateAttrs(rule, $);\n      errors = errors.concat(attrErrors);\n    }\n\n    // Recursive with childs element\n    if (rule.childs.length > 0) {\n      errors = rule.childs.reduce(\n        (_errs, r) =>\n          _errs.concat(\n            this.validateRule(\n              {\n                rule: this.createTagRule(null, r, rule.tagName),\n                $\n              },\n              errors\n            )\n          ),\n        []\n      );\n    }\n    return errors;\n  }\n\n  /**\n   * Validate Attributes of each element\n   *    1. Check attr required or not\n   *    2. Check attr required & attr has specified value\n   *\n   * @param {TagRule} rule\n   * @param {*} $ DOMElement wrapped by cheerio object\n   */\n  validateAttrs(rule, $) {\n    const { attrs, parent } = rule;\n    const elmLen = $.length;\n    const attrNames = Object.keys(attrs);\n    const attrMap = {};\n    let attrErrors = [];\n\n    if (elmLen === 0)\n      return attrNames.map(attrNm =>\n        this.createError(\n          rule,\n          ERROR_CODE.ERR_TAG_NOT_FOUND,\n          `<${rule.tagName} ${attrNm}='${attrs[attrNm].value ||\n            ''}'> was not found in ${\n            parent ? '<' + parent + '> tag' : 'HTML document'\n          }`\n        )\n      );\n\n    $.each((_, elm) => {\n      // Loop each element and check attrs in each one.\n      attrNames.forEach(attrNm => {\n        const { value } = attrs[attrNm];\n        if (!attrMap.hasOwnProperty(attrNm)) {\n          // present stands for number of element that contains attr, matched stands for number of attr mached value\n          attrMap[attrNm] = { present: 0, matched: 0 };\n        }\n        const attrVal = elm.attribs[attrNm];\n        if (attrVal) {\n          attrMap[attrNm].present += 1;\n          if (attrVal == value && value) {\n            attrMap[attrNm].matched += 1;\n          }\n        }\n      });\n    });\n\n    attrNames.forEach(attrNm => {\n      const { present, matched } = attrMap[attrNm];\n      const attr = attrs[attrNm];\n      if (attr.required) {\n        const notPresent = elmLen - present;\n        if (notPresent > 0) {\n          attrErrors.push(\n            this.createError(\n              rule,\n              ERROR_CODE.ERR_ATTR_NOT_FOUND,\n              `There are ${notPresent} <${\n                rule.tagName\n              }> tags without [${attrNm}] attribute`\n            )\n          );\n        }\n      }\n\n      if (attr.value) {\n        const notMatched = elmLen - matched;\n        if (notMatched > 0 && notMatched < elmLen && !attr.min) {\n          let errMsg = `There are ${elmLen} <${\n            rule.tagName\n          }> tags but there are ${notMatched} tags have no attribute [${attrNm}='${\n            attr.value\n          }'].`;\n          attrErrors.push(\n            this.createError(rule, ERROR_CODE.ERR_ATTR_NOT_EQUAL, errMsg)\n          );\n        }\n\n        if (matched < (attr.min || 0)) {\n          attrErrors.push(\n            this.createError(\n              rule,\n              ERROR_CODE.ERR_ATTR_NOT_EQUAL,\n              `At least ${attr.min} <${\n                rule.tagName\n              }> tags must have attribute [${attrNm}='${\n                attr.value\n              }']. Need more ${attr.min - matched} <${\n                rule.tagName\n              } ${attrNm}='${attr.value}'> tags.`\n            )\n          );\n        }\n\n        if (notMatched === elmLen) {\n          attrErrors.push(\n            this.createError(\n              rule,\n              ERROR_CODE.ERR_ATTR_NOT_EQUAL,\n              `${parent ? '<' + parent + '> tag' : 'HTML'} required <${\n                rule.tagName\n              }> tag present with attribute [${attrNm}='${\n                attr.value\n              }'] but no one is valid`\n            )\n          );\n        }\n      }\n    });\n\n    return attrErrors;\n  }\n\n  /**\n   * Linting html or page by rules configuration\n   *\n   * @param { uri, html, file, rules}\n   *    Options required uri | html | file && rules && output\n   *    output is an object that has 2 props: { type, path }\n   *      output.type must be either of [console, file]\n   *      output.path required when output.type equals to file and file is a path\n   */\n  async lint({\n    uri,\n    html,\n    file,\n    rules,\n    output = { type: 'console', silence: false }\n  }) {\n    // Make sure that every argument present correctly\n    if (!uri && !html && !file)\n      throw new Error(\n        'You must provide either uri, html, file or readable stream for linting.'\n      );\n    if (rules) {\n      this.initRules(rules);\n    }\n\n    // create cheerio instance based on html content or loading from uri\n    let $;\n    if (uri) {\n      $ = await loadUrl(uri);\n    } else if (html) {\n      $ = await loadHTML(html);\n    } else if (file) {\n      $ = await loadFile(file);\n    }\n\n    // assign cheerio element object for reach rule.\n    this.assignElement($);\n\n    // Get all tags in rules configurations and validate each one.\n    this.errors = this.tags.reduce(\n      (errors, tag) => errors.concat(this.validate(tag)),\n      []\n    );\n\n    // If there is any invalid term, the errors size will be greater than 0\n    if (this.errors.length === 0) return this.errors;\n\n    return this.writeOut(output);\n  }\n\n  /**\n   * Write result to stdout or file\n   *\n   * @param {Object} output -> { type, file }\n   */\n  async writeOut(output) {\n    if (output) {\n      const { type, silence } = output;\n      let file = null;\n      if (['console', 'file'].indexOf(type) === -1)\n        throw new Error(\n          `Output type [${type}] is not valid. Accepted output are [console, file]`\n        );\n\n      if (type === 'console') {\n        if (!silence) this.printErrors();\n        return this.errors;\n      }\n\n      if (type === 'file' && !output.path) {\n        throw new Error('Provied path must be correct and existed');\n      }\n\n      if (typeof output.path === 'string') {\n        file = fs.createWriteStream(output.path);\n      } else {\n        file = output.path;\n      }\n\n      const textToWrite = this.toOutputString();\n\n      return new Promise((resolve, reject) => {\n        file.once('open', () => {\n          file.write(new Buffer(textToWrite, 'utf8'));\n          file.end();\n        });\n\n        file.on('finish', () => {\n          resolve(this.errors);\n        });\n      });\n    }\n  }\n\n  /**\n   * Create result string with line by line style\n   *\n   * @returns {string}\n   */\n  toOutputString() {\n    let str = '';\n    let i = 0;\n    this.errors.forEach(({ code, message }) => {\n      str += `[${++i}][${code}] ${message}\\n`;\n    });\n    return str;\n  }\n\n  /**\n   * Show result string in console\n   *\n   */\n  printErrors() {\n    console.log(this.toOutputString());\n  }\n}\n\nmodule.exports = SEOLinter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/linter.js","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/regenerator/index.js\n// module id = 10\n// module chunks = 0","module.exports = require(\"regenerator-runtime\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"regenerator-runtime\"\n// module id = 11\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 12\n// module chunks = 0","exports.ERROR_CODE = {\n  ERR_TAG_NOT_FOUND: 'TAG001', // Tag required but not existed\n  ERR_TAG_MAX_EXCEED: 'TAG002', // Tag required total of element is X but has exceed the limit\n  ERR_TAG_MIN_UNDER: 'TAG003', // Tag required total of element is Y but has under the limit\n  ERR_ATTR_NOT_FOUND: 'ATTR001', // Tag requires attr present but not\n  ERR_ATTR_NOT_EQUAL: 'ATTR002' // Tag requires attr present with value but not\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants/index.js"],"sourceRoot":""}